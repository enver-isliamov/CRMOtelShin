# Взаимодействие UI и Google Sheets (Архитектура и Логика)

Этот документ описывает технические детали взаимодействия между Frontend (React приложение) и Backend (Google Apps Script + Google Sheets).

---

## 1. Общая Архитектура

Приложение построено по принципу **Client-Server**, где:
*   **Frontend:** React Single Page Application (SPA). Отправляет HTTP запросы.
*   **Transport Layer:** `fetch` API. Данные передаются методом `POST`.
*   **Backend:** Скрипт Google Apps Script (GAS), развернутый как веб-приложение (`doPost`).
*   **Database:** Google Таблица (Sheets) выступает в роли реляционной базы данных.
*   **File Storage:** Google Drive (для фото).

### Протокол обмена данными
Чтобы избежать проблем с **CORS (Cross-Origin Resource Sharing)** и редиректами Google (HTTP 302), используется специфический метод передачи:

1.  **Request:**
    *   Method: `POST`
    *   Header: `Content-Type: text/plain;charset=utf-8` (Это предотвращает Preflight OPTIONS запрос).
    *   Body: JSON-строка (`JSON.stringify(payload)`).
2.  **Payload Structure:**
    ```json
    {
      "action": "имя_функции",
      "user": "Имя_пользователя",
      ...параметры (client, id, message и т.д.)
    }
    ```
3.  **Response:**
    *   Всегда возвращается JSON.
    *   Успех: `{ "status": "success", ...данные }`
    *   Ошибка: `{ "status": "error", "message": "...", "debug": "..." }`

---

## 2. Бэкенд (Google Apps Script)

Скрипт (`Code.gs`) является единой точкой входа.

### 2.1. Точка входа: `doPost(e)`
Это главная функция, которая запускается при каждом запросе от React.
**Логика работы:**
1.  **Блокировка (`LockService`):** Включается `lock.waitLock(10000)`. Это критически важно, чтобы два одновременных запроса не сломали таблицу (Race Condition).
2.  **Парсинг:** Скрипт пытается извлечь данные из `e.postData.contents` (сырой JSON) или `e.parameter.payload` (если браузер отправил как форму). Реализован "всеядный" парсер.
3.  **Маршрутизация:** Проверяет поле `action` и передает управление в `routeAction`.
4.  **Обработка ошибок:** Любая ошибка оборачивается в JSON с полем `debug`, чтобы React мог показать её пользователю.

### 2.2. Маршрутизатор: `routeAction(payload)`
`Switch`-конструкция, которая выбирает бизнес-логику в зависимости от `action`:

| Action | Функция GAS | Описание |
| :--- | :--- | :--- |
| `getclients` | `getClientsAndArchive` | Читает листы "WebBase" и "Archive". |
| `add` | `addRow` | Добавляет новую строку в конец таблицы. |
| `update` | `updateRow` | Ищет строку по ID и обновляет ячейки. |
| `delete` | `deleteRow` | Удаляет строку по ID. |
| `reorder` | `reorderClient` | **Сложная логика:** Архивация + Обновление. |
| `uploadfile` | `uploadFile` | Декодирует Base64 и сохраняет на Google Disk. |
| `sendMessage` | `sendMessage` | Отправляет запрос в Telegram API. |
| `testconnection`| (inline) | Возвращает версию скрипта для диагностики. |

---

## 3. Детальное описание потоков данных

### 3.1. Чтение данных (`getclients`)
1.  **Frontend:** Вызывает `api.fetchClients()`.
2.  **Backend:**
    *   Открывает листы `WebBase` и `Archive`.
    *   Читает весь диапазон данных (`getDataRange().getValues()`).
    *   Первая строка используется как ключи объекта (Заголовки).
    *   Преобразует массив массивов в массив объектов JSON.
    *   Даты (`Date` objects) конвертируются в ISO-строки.
3.  **Frontend:** Получает JSON. Парсит строки дат обратно в JS Date объекты, парсит числа (валюту).

### 3.2. Добавление / Обновление клиента (`add`, `update`)
1.  **Frontend:** Формирует объект `Client`. Массив фото (`photoUrls`) объединяется в строку через запятую.
2.  **Backend:**
    *   `addRow`: Берет заголовки столбцов таблицы. Сопоставляет ключи из пришедшего JSON с заголовками. Формирует массив для вставки. Использует `appendRow`.
    *   `updateRow`: Сначала ищет номер строки (`rowIndex`) по ID клиента. Затем обновляет только эту строку.
    *   Записывает событие в лист `History`.

### 3.3. Логика Переоформления (`reorder`) — Критический процесс
Используется, когда существующий клиент сдает шины повторно. Мы не удаляем старую запись, а переносим её в историю.

1.  **Frontend:** Отправляет `action: 'reorder'`, `oldClientId` и новый объект `client`.
2.  **Backend (`reorderClient`):**
    *   **Шаг 1:** Находит текущую строку клиента в листе `WebBase`.
    *   **Шаг 2:** Копирует все данные из этой строки в лист `Archive`. Добавляет текущую дату как "Дата архивации".
    *   **Шаг 3:** Берет *ту же самую строку* в `WebBase` и перезаписывает её новыми данными (новые шины, новые даты, новая цена).
    *   **Результат:** ID клиента может сохраниться или обновиться (зависит от логики фронта), история сохранена в Архиве, активная база чиста.

### 3.4. Загрузка файлов (`uploadfile`)
Google Apps Script не умеет принимать `multipart/form-data` стандартным способом через `doPost`.
1.  **Frontend:**
    *   Читает файл через `FileReader`.
    *   Конвертирует файл в строку Base64.
    *   Отправляет JSON: `{ action: 'uploadfile', fileData: 'base64...', filename: '...', mimeType: '...' }`.
2.  **Backend:**
    *   Декодирует строку: `Utilities.base64Decode(payload.fileData)`.
    *   Создает Blob.
    *   Проверяет/Создает папку на Диске: `TireCRMPhotos / [Договор_Имя]`.
    *   Сохраняет файл.
    *   Устанавливает права доступа "Anyone with link view".
    *   Возвращает публичную ссылку `https://drive.google.com/...`.

### 3.5. Telegram Уведомления (`sendMessage`)
1.  **Frontend:** Формирует HTML-сообщение (подставляет данные в шаблон).
2.  **Backend:**
    *   Берет токен бота из `ScriptProperties`.
    *   Делает запрос `UrlFetchApp.fetch('https://api.telegram.org/bot<TOKEN>/sendMessage')`.
    *   Возвращает результат.

---

## 4. Диагностика и Ошибки

### 4.1. Проверка соединения (`testconnection`)
Эта функция создана для обхода потенциальных проблем с парсингом или версиями скрипта.
*   Она обрабатывается в `doPost` **до** входа в основной `switch`.
*   Возвращает: Версию скрипта, Имя таблицы.
*   Если Frontend получает ошибку "Неверное действие" на этот запрос, он понимает, что пользователь не развернул "Новую версию" скрипта.

### 4.2. Логирование (`getlogs`)
*   Любое изменение данных (Add, Update, Reorder) записывается в лист `History` (для аудита действий).
*   Технические ошибки могут записываться в лист `Logs` (реализовано частично, приоритет отдается возврату ошибки на клиент).

## 5. Связь полей (Frontend Types <-> Sheet Headers)

Система динамическая. Имена полей в интерфейсе `Client` (файл `types.ts`) должны в точности совпадать с заголовками столбцов в Google Таблице.

**Ключевые поля:**
*   `id` -> id (Уникальный ключ)
*   `Имя клиента` -> Имя клиента
*   `Телефон` -> Телефон
*   `photoUrls` -> photoUrls (Хранит ссылки через запятую: `url1,url2`)
*   `Начало`, `Окончание` -> Даты (хранятся в таблице как даты или строки ISO).

Если добавить новый столбец в Google Таблицу (например, "Email"), и добавить поле в интерфейс React, система автоматически начнет его читать и писать без изменения кода бэкенда (благодаря функции `getFullSheetData` и `addRow`, которые работают динамически по заголовкам).